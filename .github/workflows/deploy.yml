name: Terraform Deploy

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  actions: read

jobs:
  # <-- CHANGE: This job now only handles the Terraform infrastructure
  build_and_deploy_infra:
    name: Build and Deploy Infrastructure
    runs-on: ubuntu-latest
    environment: production
    outputs:
      resource_group_name: ${{ steps.tfout.outputs.resource_group_name }}
      web_app_hostname: ${{ steps.tfout.outputs.web_app_hostname }}
    defaults:
      run:
        shell: bash
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -input=false

      - name: Terraform Format
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -input=false -out=tfplan

      - name: Terraform Apply (main)
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve -input=false tfplan
      
      - name: Get Terraform Outputs
        if: github.ref == 'refs/heads/main'
        id: tfout
        run: |
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "web_app_hostname=$(terraform output -raw web_app_hostname)" >> $GITHUB_OUTPUT
      
      # <-- CHANGE: The "Deploy sample index.html" step has been removed from this job.

  # <-- CHANGE: This is a new job to handle the code deployment from a secure location.
  deploy_app_code:
    name: Deploy Application Code
    needs: build_and_deploy_infra
    if: github.ref == 'refs/heads/main'
    runs-on: self-hosted # <-- IMPORTANT: Runs on your runner inside the VNet
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy sample index.html to Web App
        run: |
          RESOURCE_GROUP_NAME="${{ needs.build_and_deploy_infra.outputs.resource_group_name }}"
          HOST="${{ needs.build_and_deploy_infra.outputs.web_app_hostname }}"
          APP_NAME="${HOST%%.azurewebsites.net}"

          echo "Packaging application for deployment..."
          zip -r app.zip ./terraform/www -j >/dev/null

          echo "Deploying to app '$APP_NAME' in RG '$RESOURCE_GROUP_NAME'"
          # <-- CHANGE: Using the modern, recommended 'az webapp deploy' command
          az webapp deploy \
            --resource-group "$RESOURCE_GROUP_NAME" \
            --name "$APP_NAME" \
            --src-path app.zip \
            --type zip

  positive-test:
    name: Positive test (inside VNet should be 200)
    needs: [build_and_deploy_infra, deploy_app_code] # <-- Depends on both previous jobs
    if: github.ref == 'refs/heads/main' && vars.ENABLE_POSITIVE_TEST == 'true'
    runs-on: self-hosted
    
    steps:
      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Curl Web App from inside VNet
        run: |
          HOST="${{ needs.build_and_deploy_infra.outputs.web_app_hostname }}"
          
          if [ -z "$HOST" ]; then
            echo "::error ::web_app_hostname output not received from terraform job"; exit 1
          fi
          
          # Add a small delay to allow the app to restart after deployment
          echo "Waiting 30 seconds for the app to be ready..."
          sleep 30

          URL="https://${HOST}"
          echo "Testing from inside VNet: $URL"
          
          set +e
          CODE=$(curl --insecure -s -o /dev/null -w "%{http_code}" "$URL")
          set -e
          
          echo "HTTP response: $CODE"
          if [ "$CODE" -ne 200 ]; then
            echo "::error ::Expected 200 from inside VNet, got $CODE"
            exit 1
          fi
          echo "âœ… Positive test passed (reachable from inside VNet)."